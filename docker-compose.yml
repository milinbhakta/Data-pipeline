# Docker Compose file to orchestrate all services and applications
version: "3.9"

services:
  # RabbitMQ service configuration
  rabbitmq:
    build: ./rabbitmq  # Build context for RabbitMQ
    ports:
      - "5672:5672"  # Expose RabbitMQ's default port
      - "15672:15672"  # Expose RabbitMQ's management interface port
    restart: always  # Always restart the service if it stops
    volumes:
      - rabbitmqdata:/var/lib/rabbitmq/  # Persist RabbitMQ data
    healthcheck:  # Health check using rabbitmqctl status command
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 5s
      retries: 5

  # PostgreSQL service configuration
  postgres:
    build: ./postgres  # Build context for PostgreSQL
    ports:
      - "5432:5432"  # Expose PostgreSQL's default port
    environment:  # Environment variables for PostgreSQL
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    depends_on:  # Depend on RabbitMQ service and wait until it's healthy
      rabbitmq:
        condition: service_healthy
    restart: always  # Always restart the service if it stops
    volumes:
      - pgdata:/var/lib/postgresql/data  # Persist PostgreSQL data
    healthcheck:  # Health check using pg_isready command
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Elasticsearch service configuration
  elasticsearch:
    container_name: elasticsearch  # Custom container name
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.3  # Elasticsearch image
    environment:  # Environment variables for Elasticsearch
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - bootstrap.memory_lock=true
      - xpack.security.enabled=false
    ports:
      - "9200:9200"  # Expose Elasticsearch's HTTP port
      - "9300:9300"  # Expose Elasticsearch's transport port
    depends_on:  # Depend on PostgreSQL service and wait until it's healthy
      postgres:
        condition: service_healthy
    restart: always  # Always restart the service if it stops
    volumes:
      - elasticvolume:/usr/share/elasticsearch/data  # Persist Elasticsearch data
    healthcheck:  # Health check using curl command
      test: ["CMD", "curl", "-f", "http://elasticsearch:9200"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Logstash service configuration
  logstash:
    container_name: logstash  # Custom container name
    build:  # Build context and Dockerfile for Logstash
      context: ./logstash/
      dockerfile: Dockerfile
    ports:
      - "5000:5000"  # Expose Logstash's default port
    environment:  # Environment variables for Logstash
      - CONFIG_SUPPORT_ESCAPE=true
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    depends_on:  # Depend on Elasticsearch and PostgreSQL services
      - elasticsearch
      - postgres
    restart: always  # Always restart the service if it stops
    volumes:
      - logstashvolume:/usr/share/logstash/data  # Persist Logstash data
    healthcheck:  # Health check using ps command
      test: ["CMD-SHELL", "ps aux | grep 'logstash' || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 5

# Define volumes for data persistence
volumes:
  pgdata:  # Volume for PostgreSQL data
  elasticvolume:  # Volume for Elasticsearch data
  logstashvolume:  # Volume for Logstash data
  rabbitmqdata:  # Volume for RabbitMQ data